## 并发

### 线程安全

java线程安全的实现手段包括

+ 互斥同步(mutual exclusion & synchronization)

  是指保证一个共享变量在一个时刻只能被一天线程使用。实现互斥同步分方式包括：

  + 临界区(critical section)
  + 互斥量(mutex)
  + 信号量(semaphore)

  synchronized关键字，juc包里面的Lock都能实现互斥同步。

+ 非阻塞同步(non-blocking synchronization)

  互斥同步是一种悲观的策略，而非阻塞同步则是一种乐观的策略。简单的说，这个策略就是不管冲突的风险，先进行操作，如果没有别的线程竞争，那就直接成功，如果产生了冲突，就采取别的补偿措施。CAS是其中的一种手段。但是CAS无法解决"ABA问题"。

+ 无同步方案

  在程序设计的是，避免出现贡献变量的情况，这样就不需要进行同步。

### 锁优化

jdk5升级到jdk6以后，有了很多锁优化

+ 适应性自旋(adaptive spinning)

  一般情况来说，一个线程获取了锁以后，很快会释放，如果另外的线程每次获取失败都挂起的话，会浪费很多资源，自旋锁就是为了提高这样场景的性能。使用自旋锁的时候，线程获取锁失败不会马上挂起，而会执行一个忙循环(自旋)，到失败一定次数以后，还是会照样挂起。这样就能避免线程切换的开销，但是它会占用处理器。

  适应性自旋意味着，自旋的时间和次数不是固定的，会根据同一个锁上的自旋时间以及锁的拥有者的状态来动态决定。

+ 锁消除(lock elimimation)

  锁消除是指在运行过程中，对一些在代码层面做了同步限制，但是运行时检测到时不会出现共享数据的锁进行消除。这个判断的依据是逃逸分析的结果，如果检测到一个堆对象是不会逃逸到别的线程，那么这个对象可以当做栈上数据对待。

+ 锁膨胀(lock coarsening)

+ 轻量级锁(lightweight locking)

  轻量级锁和下面的偏向锁的实现，都是基于对象在内存布局中的对象头对象中的Mark word。Mark word会存放对象的哈希码、GC分代年龄、锁状态等。

  当线程进入到同步的代码块中，如果发现同步对象的锁没被锁定，就会在当前线程的栈帧中创建锁记录(lock record)来存放锁对象mark workd的拷贝。然后虚拟机会使用CAS尝试把锁对象的mark word设置为指向lock record的指针并且修改mark word锁标记位。更新成功的话，那这个线程就获得了轻量级锁。

  如果设置失败，这就意味着有另外的线程也在争抢这个锁。当有两个线程同时争抢一个锁的时候，就回膨胀成为重量级锁(互斥量)。膨胀为重量级锁以后，会让线程释放资源，提高cpu的利用率。

  由此可见，轻量级适用于低冲突的情况，如果高冲突的情况下性能会比重量级锁要差。

+ 偏向锁(biased locking)

  偏向锁适用在无竞争的场景下。

  偏向锁会偏向于第一个获得它的线程。对于一个锁对象，第一次被一条线程获取到的时候，这个锁对象会进入到偏向锁状态，同时也通过CAS把这条线程的ID记录在锁对象的mark word中。往后，这线程进入到这个锁相关的同步块的时候，都不需要进行任何同步操作。当另外一条线程尝试去获取这个锁的时候，这个锁机会撤销偏向状态。

